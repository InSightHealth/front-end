// E:/fuchuang/learn/demo1/node_modules/recorder-core/src/extensions/frequency.histogram.view.js
(function(factory) {
  var browser = typeof window == "object" && !!window.document;
  var win = browser ? window : Object;
  var rec = win.Recorder, ni = rec.i18n;
  factory(rec, ni, ni.$T, browser);
})(function(Recorder, i18n, $T, isBrowser) {
  "use strict";
  var FrequencyHistogramView = function(set) {
    return new fn(set);
  };
  var ViewTxt = "FrequencyHistogramView";
  var fn = function(set) {
    var This = this;
    var o = {
      /*
      		elem:"css selector" //自动显示到dom，并以此dom大小为显示大小
      			//或者配置显示大小，手动把frequencyObj.elem显示到别的地方
      		,width:0 //显示宽度
      		,height:0 //显示高度
      		
      H5环境以上配置二选一
      		
      		compatibleCanvas: CanvasObject //提供一个兼容H5的canvas对象，需支持getContext("2d")，支持设置width、height，支持drawImage(canvas,...)
      		,width:0 //canvas显示宽度
      		,height:0 //canvas显示高度
      非H5环境使用以上配置
      		*/
      scale: 2,
      fps: 20,
      lineCount: 30,
      widthRatio: 0.6,
      spaceWidth: 0,
      minHeight: 0,
      position: -1,
      mirrorEnable: false,
      stripeEnable: true,
      stripeHeight: 3,
      stripeMargin: 6,
      fallDuration: 1e3,
      stripeFallDuration: 3500,
      linear: [0, "rgba(0,187,17,1)", 0.5, "rgba(255,215,0,1)", 1, "rgba(255,102,0,1)"],
      stripeLinear: null,
      shadowBlur: 0,
      shadowColor: "#bbb",
      stripeShadowBlur: -1,
      stripeShadowColor: "",
      fullFreq: false,
      onDraw: function(frequencyData, sampleRate) {
      }
    };
    for (var k in set) {
      o[k] = set[k];
    }
    ;
    This.set = set = o;
    var cCanvas = "compatibleCanvas";
    if (set[cCanvas]) {
      var canvas = This.canvas = set[cCanvas];
    } else {
      if (!isBrowser)
        throw new Error($T.G("NonBrowser-1", [ViewTxt]));
      var elem = set.elem;
      if (elem) {
        if (typeof elem == "string") {
          elem = document.querySelector(elem);
        } else if (elem.length) {
          elem = elem[0];
        }
        ;
      }
      ;
      if (elem) {
        set.width = elem.offsetWidth;
        set.height = elem.offsetHeight;
      }
      ;
      var thisElem = This.elem = document.createElement("div");
      thisElem.style.fontSize = 0;
      thisElem.innerHTML = '<canvas style="width:100%;height:100%;"/>';
      var canvas = This.canvas = thisElem.querySelector("canvas");
      if (elem) {
        elem.innerHTML = "";
        elem.appendChild(thisElem);
      }
      ;
    }
    ;
    var scale = set.scale;
    var width = set.width * scale;
    var height = set.height * scale;
    if (!width || !height) {
      throw new Error($T.G("IllegalArgs-1", [ViewTxt + " width=0 height=0"]));
    }
    ;
    canvas.width = width;
    canvas.height = height;
    var ctx = This.ctx = canvas.getContext("2d");
    if (!Recorder.LibFFT) {
      throw new Error($T.G("NeedImport-2", [ViewTxt, "src/extensions/lib.fft.js"]));
    }
    ;
    This.fft = Recorder.LibFFT(1024);
    This.lastH = [];
    This.stripesH = [];
  };
  fn.prototype = FrequencyHistogramView.prototype = {
    genLinear: function(ctx, colors, from, to) {
      var rtv = ctx.createLinearGradient(0, from, 0, to);
      for (var i = 0; i < colors.length; ) {
        rtv.addColorStop(colors[i++], colors[i++]);
      }
      ;
      return rtv;
    },
    input: function(pcmData, powerLevel, sampleRate) {
      var This = this;
      This.sampleRate = sampleRate;
      This.pcmData = pcmData;
      This.pcmPos = 0;
      This.inputTime = Date.now();
      This.schedule();
    },
    schedule: function() {
      var This = this, set = This.set;
      var interval = Math.floor(1e3 / set.fps);
      if (!This.timer) {
        This.timer = setInterval(function() {
          This.schedule();
        }, interval);
      }
      ;
      var now = Date.now();
      var drawTime = This.drawTime || 0;
      if (now - This.inputTime > set.stripeFallDuration * 1.3) {
        clearInterval(This.timer);
        This.timer = 0;
        This.lastH = [];
        This.stripesH = [];
        This.draw(null, This.sampleRate);
        return;
      }
      ;
      if (now - drawTime < interval) {
        return;
      }
      ;
      This.drawTime = now;
      var bufferSize = This.fft.bufferSize;
      var pcm = This.pcmData;
      var pos = This.pcmPos;
      var arr = new Int16Array(bufferSize);
      for (var i = 0; i < bufferSize && pos < pcm.length; i++, pos++) {
        arr[i] = pcm[pos];
      }
      ;
      This.pcmPos = pos;
      var frequencyData = This.fft.transform(arr);
      This.draw(frequencyData, This.sampleRate);
    },
    draw: function(frequencyData, sampleRate) {
      var This = this, set = This.set;
      var ctx = This.ctx;
      var scale = set.scale;
      var width = set.width * scale;
      var height = set.height * scale;
      var lineCount = set.lineCount;
      var bufferSize = This.fft.bufferSize;
      var position = set.position;
      var posAbs = Math.abs(set.position);
      var originY = position == 1 ? 0 : height;
      var heightY = height;
      if (posAbs < 1) {
        heightY = heightY / 2;
        originY = heightY;
        heightY = Math.floor(heightY * (1 + posAbs));
        originY = Math.floor(position > 0 ? originY * (1 - posAbs) : originY * (1 + posAbs));
      }
      ;
      var lastH = This.lastH;
      var stripesH = This.stripesH;
      var speed = Math.ceil(heightY / (set.fallDuration / (1e3 / set.fps)));
      var stripeSpeed = Math.ceil(heightY / (set.stripeFallDuration / (1e3 / set.fps)));
      var stripeMargin = set.stripeMargin * scale;
      var Y0 = 1 << (Math.round(Math.log(bufferSize) / Math.log(2) + 3) << 1);
      var logY0 = Math.log(Y0) / Math.log(10);
      var dBmax = 20 * Math.log(32767) / Math.log(10);
      var fftSize = bufferSize / 2, fftSize5k = fftSize;
      if (!set.fullFreq) {
        fftSize5k = Math.min(fftSize, Math.floor(fftSize * 5e3 / (sampleRate / 2)));
      }
      var isFullFreq = fftSize5k == fftSize;
      var line80 = isFullFreq ? lineCount : Math.round(lineCount * 0.8);
      var fftSizeStep1 = fftSize5k / line80;
      var fftSizeStep2 = isFullFreq ? 0 : (fftSize - fftSize5k) / (lineCount - line80);
      var fftIdx = 0;
      for (var i = 0; i < lineCount; i++) {
        var start = Math.ceil(fftIdx);
        if (i < line80) {
          fftIdx += fftSizeStep1;
        } else {
          fftIdx += fftSizeStep2;
        }
        ;
        var end = Math.ceil(fftIdx);
        if (end == start)
          end++;
        end = Math.min(end, fftSize);
        var maxAmp = 0;
        if (frequencyData) {
          for (var j = start; j < end; j++) {
            maxAmp = Math.max(maxAmp, Math.abs(frequencyData[j]));
          }
          ;
        }
        ;
        var dB = maxAmp > Y0 ? Math.floor((Math.log(maxAmp) / Math.log(10) - logY0) * 17) : 0;
        var h = heightY * Math.min(dB / dBmax, 1);
        lastH[i] = (lastH[i] || 0) - speed;
        if (h < lastH[i]) {
          h = lastH[i];
        }
        ;
        if (h < 0) {
          h = 0;
        }
        ;
        lastH[i] = h;
        var shi = stripesH[i] || 0;
        if (h && h + stripeMargin > shi) {
          stripesH[i] = h + stripeMargin;
        } else {
          var sh = shi - stripeSpeed;
          if (sh < 0) {
            sh = 0;
          }
          ;
          stripesH[i] = sh;
        }
        ;
      }
      ;
      ctx.clearRect(0, 0, width, height);
      var linear1 = This.genLinear(ctx, set.linear, originY, originY - heightY);
      var stripeLinear1 = set.stripeLinear && This.genLinear(ctx, set.stripeLinear, originY, originY - heightY) || linear1;
      var linear2 = This.genLinear(ctx, set.linear, originY, originY + heightY);
      var stripeLinear2 = set.stripeLinear && This.genLinear(ctx, set.stripeLinear, originY, originY + heightY) || linear2;
      var mirrorEnable = set.mirrorEnable;
      var mirrorCount = mirrorEnable ? lineCount * 2 - 1 : lineCount;
      var widthRatio = set.widthRatio;
      var spaceWidth = set.spaceWidth * scale;
      if (spaceWidth != 0) {
        widthRatio = (width - spaceWidth * (mirrorCount + 1)) / width;
      }
      ;
      for (var i = 0; i < 2; i++) {
        var lineFloat = Math.max(1 * scale, width * widthRatio / mirrorCount);
        var lineWN = Math.floor(lineFloat), lineWF = lineFloat - lineWN;
        var spaceFloat = (width - mirrorCount * lineFloat) / (mirrorCount + 1);
        if (spaceFloat > 0 && spaceFloat < 1) {
          widthRatio = 1;
          spaceFloat = 0;
        } else
          break;
      }
      ;
      var minHeight = set.minHeight * scale;
      var XFloat = mirrorEnable ? (width - lineWN) / 2 - spaceFloat : 0;
      for (var iMirror = 0; iMirror < 2; iMirror++) {
        if (iMirror) {
          ctx.save();
          ctx.scale(-1, 1);
        }
        var xMirror = iMirror ? width : 0;
        ctx.shadowBlur = set.shadowBlur * scale;
        ctx.shadowColor = set.shadowColor;
        for (var i = 0, xFloat = XFloat, wFloat = 0, x, y, w, h; i < lineCount; i++) {
          xFloat += spaceFloat;
          x = Math.floor(xFloat) - xMirror;
          w = lineWN;
          wFloat += lineWF;
          if (wFloat >= 1) {
            w++;
            wFloat--;
          }
          h = Math.max(lastH[i], minHeight);
          if (originY != 0) {
            y = originY - h;
            ctx.fillStyle = linear1;
            ctx.fillRect(x, y, w, h);
          }
          ;
          if (originY != height) {
            ctx.fillStyle = linear2;
            ctx.fillRect(x, originY, w, h);
          }
          ;
          xFloat += w;
        }
        ;
        if (set.stripeEnable) {
          var stripeShadowBlur = set.stripeShadowBlur;
          ctx.shadowBlur = (stripeShadowBlur == -1 ? set.shadowBlur : stripeShadowBlur) * scale;
          ctx.shadowColor = set.stripeShadowColor || set.shadowColor;
          var stripeHeight = set.stripeHeight * scale;
          for (var i = 0, xFloat = XFloat, wFloat = 0, x, y, w, h; i < lineCount; i++) {
            xFloat += spaceFloat;
            x = Math.floor(xFloat) - xMirror;
            w = lineWN;
            wFloat += lineWF;
            if (wFloat >= 1) {
              w++;
              wFloat--;
            }
            h = stripesH[i];
            if (originY != 0) {
              y = originY - h - stripeHeight;
              if (y < 0) {
                y = 0;
              }
              ;
              ctx.fillStyle = stripeLinear1;
              ctx.fillRect(x, y, w, stripeHeight);
            }
            ;
            if (originY != height) {
              y = originY + h;
              if (y + stripeHeight > height) {
                y = height - stripeHeight;
              }
              ;
              ctx.fillStyle = stripeLinear2;
              ctx.fillRect(x, y, w, stripeHeight);
            }
            ;
            xFloat += w;
          }
          ;
        }
        ;
        if (iMirror) {
          ctx.restore();
        }
        if (!mirrorEnable)
          break;
      }
      ;
      if (frequencyData) {
        set.onDraw(frequencyData, sampleRate);
      }
      ;
    }
  };
  Recorder[ViewTxt] = FrequencyHistogramView;
});
//# sourceMappingURL=recorder-core_src_extensions_frequency__histogram__view__js.js.map
