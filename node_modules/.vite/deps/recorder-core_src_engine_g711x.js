// E:/fuchuang/learn/demo1/node_modules/recorder-core/src/engine/g711x.js
(function(factory) {
  var browser = typeof window == "object" && !!window.document;
  var win = browser ? window : Object;
  var rec = win.Recorder, ni = rec.i18n;
  factory(rec, ni, ni.$T, browser);
})(function(Recorder, i18n, $T, isBrowser) {
  "use strict";
  var regEngine = function(key, desc, enc, dec) {
    Recorder.prototype["enc_" + key] = {
      stable: true,
      fast: true,
      getTestMsg: function() {
        return $T("d8YX::{1}；{2}音频文件无法直接播放，可用Recorder.{2}2wav()转码成wav播放；采样率比特率设置无效，固定为8000hz采样率、16位，每个采样压缩成8位存储，音频文件大小为8000字节/秒；如需任意采样率支持，请使用Recorder.{2}_encode()方法", 0, desc, key);
      }
    };
    Recorder.prototype[key] = function(res, True, False) {
      var This = this, set = This.set, srcSampleRate = set.sampleRate, sampleRate = 8e3;
      set.bitRate = 16;
      set.sampleRate = sampleRate;
      if (srcSampleRate > sampleRate) {
        res = Recorder.SampleData([res], srcSampleRate, sampleRate).data;
      } else if (srcSampleRate < sampleRate) {
        False($T("29UK::数据采样率低于{1}", 0, sampleRate));
        return;
      }
      ;
      var bytes = enc(res);
      True(bytes.buffer, "audio/" + key);
    };
    Recorder[key + "_encode"] = function(pcm) {
      return enc(pcm);
    };
    Recorder[key + "_decode"] = function(bytes) {
      return dec(bytes);
    };
    Recorder[key + "2wav"] = function(g711xBlob, True, False) {
      if (!Recorder.prototype.wav) {
        False($T.G("NeedImport-2", [key + "2wav", "src/engine/wav.js"]));
        return;
      }
      ;
      var loadOk = function(arrB, dArrB) {
        var bytes = new Uint8Array(arrB);
        var pcm = dec(bytes);
        var rec = Recorder({
          type: "wav",
          sampleRate: 8e3,
          bitRate: 16
        });
        if (dArrB)
          rec.dataType = "arraybuffer";
        rec.mock(pcm, 8e3).stop(function(wavBlob, duration, mime) {
          True(wavBlob, duration, mime);
        }, False);
      };
      if (g711xBlob instanceof ArrayBuffer) {
        loadOk(g711xBlob, 1);
      } else {
        var reader = new FileReader();
        reader.onloadend = function() {
          loadOk(reader.result);
        };
        reader.readAsArrayBuffer(g711xBlob);
      }
      ;
    };
    Recorder.prototype[key + "_envCheck"] = function(envInfo, set) {
      return "";
    };
    Recorder.prototype[key + "_start"] = function(set) {
      set.bitRate = 16;
      set.sampleRate = 8e3;
      return { set, memory: new Uint8Array(5e5), mOffset: 0 };
    };
    var addBytes = function(cur, buf) {
      var bufLen = buf.length;
      if (cur.mOffset + bufLen > cur.memory.length) {
        var tmp = new Uint8Array(cur.memory.length + Math.max(5e5, bufLen));
        tmp.set(cur.memory.subarray(0, cur.mOffset));
        cur.memory = tmp;
      }
      cur.memory.set(buf, cur.mOffset);
      cur.mOffset += bufLen;
    };
    Recorder.prototype[key + "_stop"] = function(startCtx) {
      if (startCtx && startCtx.memory) {
        startCtx.memory = null;
      }
    };
    Recorder.prototype[key + "_encode"] = function(startCtx, pcm) {
      if (startCtx && startCtx.memory) {
        var set = startCtx.set;
        var bytes = enc(pcm);
        if (set.takeoffEncodeChunk) {
          set.takeoffEncodeChunk(bytes);
        } else {
          addBytes(startCtx, bytes);
        }
        ;
      }
      ;
    };
    Recorder.prototype[key + "_complete"] = function(startCtx, True, False, autoStop) {
      if (startCtx && startCtx.memory) {
        if (autoStop) {
          this[key + "_stop"](startCtx);
        }
        ;
        var buffer = startCtx.memory.buffer.slice(0, startCtx.mOffset);
        True(buffer, "audio/" + key);
      } else {
        False($T("quVJ::{1}编码器未start", 0, key));
      }
      ;
    };
  };
  var Tab = [1, 2, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
  regEngine(
    "g711a",
    "G.711 A-law (pcma)",
    function(pcm) {
      var buffer = new Uint8Array(pcm.length);
      for (var i = 0; i < pcm.length; i++) {
        var pcm_val = pcm[i], mask;
        if (pcm_val >= 0) {
          mask = 213;
        } else {
          mask = 85;
          pcm_val = -pcm_val - 1;
        }
        var seg = (Tab[pcm_val >> 8 & 127] || 8) - 1;
        var aval = seg << 4;
        if (seg < 2)
          aval |= pcm_val >> 4 & 15;
        else
          aval |= pcm_val >> seg + 3 & 15;
        buffer[i] = aval ^ mask;
      }
      return buffer;
    },
    function(bytes) {
      var buffer = new Int16Array(bytes.length);
      for (var i = 0; i < bytes.length; i++) {
        var a_val = bytes[i] ^ 85;
        var t = (a_val & 15) << 4;
        var seg = (a_val & 112) >> 4;
        switch (seg) {
          case 0:
            t += 8;
            break;
          case 1:
            t += 264;
            break;
          default:
            t += 264;
            t <<= seg - 1;
        }
        buffer[i] = a_val & 128 ? t : -t;
      }
      return buffer;
    }
  );
  regEngine(
    "g711u",
    "G.711 μ-law (pcmu、mu-law)",
    function(pcm) {
      var buffer = new Uint8Array(pcm.length);
      for (var i = 0; i < pcm.length; i++) {
        var pcm_val = pcm[i], mask;
        if (pcm_val < 0) {
          pcm_val = 132 - pcm_val;
          mask = 127;
        } else {
          pcm_val += 132;
          mask = 255;
        }
        var seg = (Tab[pcm_val >> 8 & 127] || 8) - 1;
        var uval = seg << 4 | pcm_val >> seg + 3 & 15;
        buffer[i] = uval ^ mask;
      }
      return buffer;
    },
    function(bytes) {
      var buffer = new Int16Array(bytes.length);
      for (var i = 0; i < bytes.length; i++) {
        var u_val = ~bytes[i];
        var t = ((u_val & 15) << 3) + 132;
        t <<= (u_val & 112) >> 4;
        buffer[i] = u_val & 128 ? 132 - t : t - 132;
      }
      return buffer;
    }
  );
});
//# sourceMappingURL=recorder-core_src_engine_g711x.js.map
