// E:/fuchuang/learn/demo1/node_modules/recorder-core/src/extensions/lib.fft.js
(function(factory) {
  var browser = typeof window == "object" && !!window.document;
  var win = browser ? window : Object;
  var rec = win.Recorder, ni = rec.i18n;
  factory(rec, ni, ni.$T, browser);
})(function(Recorder, i18n, $T, isBrowser) {
  "use strict";
  Recorder.LibFFT = function(bufferSize) {
    var FFT_N_LOG, FFT_N, MINY;
    var real, imag, sintable, costable;
    var bitReverse;
    var FFT_Fn = function(bufferSize2) {
      FFT_N_LOG = Math.round(Math.log(bufferSize2) / Math.log(2));
      FFT_N = 1 << FFT_N_LOG;
      MINY = (FFT_N << 2) * Math.sqrt(2);
      real = [];
      imag = [];
      sintable = [0];
      costable = [0];
      bitReverse = [];
      var i, j, k, reve;
      for (i = 0; i < FFT_N; i++) {
        k = i;
        for (j = 0, reve = 0; j != FFT_N_LOG; j++) {
          reve <<= 1;
          reve |= k & 1;
          k >>>= 1;
        }
        bitReverse[i] = reve;
      }
      var theta, dt = 2 * Math.PI / FFT_N;
      for (i = (FFT_N >> 1) - 1; i > 0; i--) {
        theta = i * dt;
        costable[i] = Math.cos(theta);
        sintable[i] = Math.sin(theta);
      }
    };
    var getModulus = function(inBuffer) {
      var i, j, k, ir, j0 = 1, idx = FFT_N_LOG - 1;
      var cosv, sinv, tmpr, tmpi;
      for (i = 0; i != FFT_N; i++) {
        real[i] = inBuffer[bitReverse[i]];
        imag[i] = 0;
      }
      for (i = FFT_N_LOG; i != 0; i--) {
        for (j = 0; j != j0; j++) {
          cosv = costable[j << idx];
          sinv = sintable[j << idx];
          for (k = j; k < FFT_N; k += j0 << 1) {
            ir = k + j0;
            tmpr = cosv * real[ir] - sinv * imag[ir];
            tmpi = cosv * imag[ir] + sinv * real[ir];
            real[ir] = real[k] - tmpr;
            imag[ir] = imag[k] - tmpi;
            real[k] += tmpr;
            imag[k] += tmpi;
          }
        }
        j0 <<= 1;
        idx--;
      }
      j = FFT_N >> 1;
      var outBuffer = new Float64Array(j);
      sinv = MINY;
      cosv = -MINY;
      for (i = j; i != 0; i--) {
        tmpr = real[i];
        tmpi = imag[i];
        if (tmpr > cosv && tmpr < sinv && tmpi > cosv && tmpi < sinv)
          outBuffer[i - 1] = 0;
        else
          outBuffer[i - 1] = Math.round(tmpr * tmpr + tmpi * tmpi);
      }
      return outBuffer;
    };
    FFT_Fn(bufferSize);
    return { transform: getModulus, bufferSize: FFT_N };
  };
});
//# sourceMappingURL=recorder-core_src_extensions_lib__fft__js.js.map
